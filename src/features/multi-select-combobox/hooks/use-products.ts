import { useInfiniteQuery } from "@tanstack/react-query";
import { PAGE_SIZE } from "@/constants/common";
import { client } from "@/lib/hono";
import { FetchProductsResponse } from "@/types/product-response";

// Function to fetch products from the API
const fetchProducts = async (
  cursor: string | null,
  searchTerm: string,
): Promise<FetchProductsResponse> => {
  // Make an API request to fetch products

  // Explanation of the Hono.js API call:
  //
  // 1. client.api.products.search.$get():
  //    - This is a type-safe API call generated by Hono.js.
  //    - 'client' is likely an instance of the Hono client.
  //    - 'api.products.search' represents the endpoint path.
  //    - '$get' indicates this is a GET request.
  //
  // 2. Query parameters:
  //    a. cursor: cursor || undefined
  //       - Used for pagination. If cursor is null, it's set to undefined.
  //       - This allows the API to know which page of results to return.
  //
  //    b. limit: PAGE_SIZE.toString()
  //       - Specifies how many items to return per page.
  //       - PAGE_SIZE is converted to a string as required by the API.
  //
  //    c. searchTerm: searchTerm
  //       - The search query to filter products.
  //       - Directly passed from the function parameter.
  //
  // 3. Type safety:
  //    - Hono.js provides type checking for the API call.
  //    - This ensures that the correct parameters are passed.
  //
  // 4. Asynchronous operation:
  //    - The call is asynchronous (uses await), returning a Promise.
  //    - This allows non-blocking execution of the API request.
  //
  // 5. Response handling:
  //    - The response will need to be checked for success and parsed.
  //    - This is typically done in the subsequent code (not shown here).

  const response = await client.api.products.search.$get({
    query: {
      cursor: cursor || undefined, // Use cursor for pagination
      limit: PAGE_SIZE.toString(), // Limit the number of products per page
      searchTerm, // Search term for filtering products
    },
  });

  // Check if the response is not okay and throw an error
  if (!response.ok) {
    throw new Error("Failed to fetch products");
  }

  // Parse the response data
  const data = await response.json();

  // Return the products and the next cursor for pagination
  return {
    products: data.products,
    nextCursor: data.nextCursor,
  };
};

// Custom hook to use products with infinite scrolling

// Explanation of useInfiniteQuery:
//
// 1. queryKey: ["infinite-product-list", searchTerm]
//    - This array uniquely identifies the query in the cache.
//    - Including searchTerm ensures different searches have separate caches.
//    - If searchTerm changes, react-query will automatically refetch the data.
//
// 2. queryFn: ({ pageParam }) => fetchProducts(pageParam as string | null, searchTerm)
//    - This function is called by react-query to fetch each page of data.
//    - pageParam is managed by react-query and represents the cursor for pagination.
//    - For the first page, pageParam will be null (as set by initialPageParam).
//    - For subsequent pages, pageParam will be the value returned by getNextPageParam.
//
// 3. initialPageParam: null as string | null
//    - Sets the initial value of pageParam when the query first runs.
//    - null indicates we're starting from the beginning of the product list.
//
// 4. getNextPageParam: (lastPage) => lastPage.nextCursor
//    - This function tells react-query how to get the next pageParam (cursor).
//    - It's called after each successful page fetch.
//    - If it returns undefined, react-query assumes there are no more pages to fetch.
//    - In this case, it returns the nextCursor from the last fetched page.
//
// Usage of this hook:
// const {
//   data,                // Contains all fetched pages
//   fetchNextPage,       // Function to manually fetch the next page
//   hasNextPage,         // Boolean indicating if there's a next page
//   isFetchingNextPage,  // Boolean indicating if the next page is being fetched
//   ... // other properties
// } = useProducts(searchTerm);
//
// - data.pages will contain an array of all fetched pages
// - Each page in data.pages will be of type FetchProductsResponse
// - To load more data, call fetchNextPage()
// - Check hasNextPage to know if there's more data to load
// - Use isFetchingNextPage to show a loading indicator while fetching the next page

export const useProducts = (searchTerm: string) => {
  return useInfiniteQuery<FetchProductsResponse>({
    // Unique key for caching and identifying this query
    // It includes the searchTerm to create separate caches for different searches
    queryKey: ["infinite-product-list", searchTerm],

    // The function that fetches the data for each page
    // pageParam is provided by react-query and represents the cursor for pagination
    queryFn: ({ pageParam }) =>
      fetchProducts(pageParam as string | null, searchTerm),

    // The initial value for pageParam when the query is first run
    // null indicates that we're starting from the beginning of the list
    initialPageParam: null as string | null,

    // Function to determine the next pageParam (cursor) based on the last fetched page
    // This is used by react-query to know how to fetch the next page
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  });
};
